<details><summary>📁 .</summary>

```text
├── .git
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   └── update.sample
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── refs
│   │   └── HEAD
│   ├── objects
│   │   ├── 01
│   │   ├── 02
│   │   ├── 06
│   │   ├── 07
│   │   ├── 0b
│   │   ├── 0c
│   │   ├── 0e
│   │   ├── 10
│   │   ├── 14
│   │   ├── 15
│   │   ├── 16
│   │   ├── 18
│   │   ├── 19
│   │   ├── 1b
│   │   ├── 1c
│   │   ├── 20
│   │   ├── 21
│   │   ├── 22
│   │   ├── 23
│   │   ├── 24
│   │   ├── 25
│   │   ├── 29
│   │   ├── 2a
│   │   ├── 2b
│   │   ├── 2f
│   │   ├── 33
│   │   ├── 37
│   │   ├── 38
│   │   ├── 39
│   │   ├── 3a
│   │   ├── 3b
│   │   ├── 3c
│   │   ├── 3d
│   │   ├── 3e
│   │   ├── 41
│   │   ├── 42
│   │   ├── 44
│   │   ├── 45
│   │   ├── 47
│   │   ├── 48
│   │   ├── 4a
│   │   ├── 4b
│   │   ├── 4d
│   │   ├── 4e
│   │   ├── 52
│   │   ├── 53
│   │   ├── 54
│   │   ├── 55
│   │   ├── 57
│   │   ├── 5c
│   │   ├── 61
│   │   ├── 62
│   │   ├── 63
│   │   ├── 67
│   │   ├── 68
│   │   ├── 69
│   │   ├── 6c
│   │   ├── 6d
│   │   ├── 6e
│   │   ├── 6f
│   │   ├── 70
│   │   ├── 71
│   │   ├── 74
│   │   ├── 77
│   │   ├── 7b
│   │   ├── 7e
│   │   ├── 80
│   │   ├── 81
│   │   ├── 82
│   │   ├── 84
│   │   ├── 85
│   │   ├── 87
│   │   ├── 8b
│   │   ├── 8c
│   │   ├── 8d
│   │   ├── 8e
│   │   ├── 8f
│   │   ├── 94
│   │   ├── 95
│   │   ├── 96
│   │   ├── 97
│   │   ├── 98
│   │   ├── 99
│   │   ├── 9a
│   │   ├── 9d
│   │   ├── 9f
│   │   ├── a2
│   │   ├── a3
│   │   ├── a4
│   │   ├── a5
│   │   ├── a6
│   │   ├── a7
│   │   ├── a9
│   │   ├── ac
│   │   ├── af
│   │   ├── b3
│   │   ├── b4
│   │   ├── b6
│   │   ├── b7
│   │   ├── b8
│   │   ├── ba
│   │   ├── bc
│   │   ├── bd
│   │   ├── be
│   │   ├── bf
│   │   ├── c0
│   │   ├── c1
│   │   ├── c2
│   │   ├── c3
│   │   ├── c4
│   │   ├── c5
│   │   ├── c8
│   │   ├── c9
│   │   ├── cb
│   │   ├── cd
│   │   ├── ce
│   │   ├── cf
│   │   ├── d1
│   │   ├── d2
│   │   ├── d4
│   │   ├── d5
│   │   ├── d6
│   │   ├── d7
│   │   ├── d8
│   │   ├── da
│   │   ├── db
│   │   ├── dc
│   │   ├── dd
│   │   ├── de
│   │   ├── e0
│   │   ├── e1
│   │   ├── e2
│   │   ├── e5
│   │   ├── e6
│   │   ├── e8
│   │   ├── e9
│   │   ├── eb
│   │   ├── ec
│   │   ├── ed
│   │   ├── ee
│   │   ├── ef
│   │   ├── f0
│   │   ├── f2
│   │   ├── f3
│   │   ├── f4
│   │   ├── f5
│   │   ├── f6
│   │   ├── f7
│   │   ├── f9
│   │   ├── fb
│   │   ├── fc
│   │   ├── fd
│   │   ├── ff
│   │   ├── info
│   │   └── pack
│   ├── refs
│   │   ├── heads
│   │   ├── remotes
│   │   └── tags
│   ├── COMMIT_EDITMSG
│   ├── config
│   ├── description
│   ├── HEAD
│   └── index
├── .github
│   └── workflows
│       ├── ci.yml
│       └── release.yml
├── .pytest_cache
│   ├── v
│   │   └── cache
│   ├── .gitignore
│   ├── CACHEDIR.TAG
│   └── README.md
├── dev-utils
│   ├── oneclick
│   │   └── tree_20250724_181742_113.json
│   ├── tree_20250724_185245_335.html
│   └── tree_20250724_185958_151.html
├── dist
│   ├── oneclick_context-0.1.2-py3-none-any.whl
│   ├── oneclick_context-0.1.2.tar.gz
│   ├── oneclick_context-0.2.2-py3-none-any.whl
│   ├── oneclick_context-0.2.2.tar.gz
│   ├── oneclick_context-0.2.4-py3-none-any.whl
│   └── oneclick_context-0.2.4.tar.gz
├── src
│   └── oneclick_context
│       ├── __pycache__
│       ├── commands
│       ├── exporters
│       ├── __init__.py
│       ├── cli.py
│       ├── core.py
│       ├── prompts.py
│       └── utils.py
├── tests
│   ├── __pycache__
│   │   ├── __init__.cpython-313.pyc
│   │   ├── test_cli.cpython-313-pytest-8.4.1.pyc
│   │   ├── test_prompts.cpython-313-pytest-8.4.1.pyc
│   │   └── test_smoke.cpython-313-pytest-8.4.1.pyc
│   ├── __init__.py
│   ├── test_cli.py
│   ├── test_prompts.py
│   └── test_smoke.py
├── .gitignore
├── all_python_sources.md
├── CHANGELOG.md
├── poetry.lock
├── prompts.bak
├── pyproject.toml
├── README.md
├── test_prompts.bak
└── tree.md
```
</details>

--- 📜 Scripts Content (.py) ---


### 📄 src\oneclick_context\__init__.py

```

```

### 📄 src\oneclick_context\cli.py

```
﻿# Standard library imports
from pathlib import Path
from typing import Optional, List

# Third-party imports
import typer

# First-party imports
from .commands.generate import generate_output
from .prompts import run_guide, run_menu

app = typer.Typer(add_completion=False, help="Generate compact file trees")

@app.callback(invoke_without_command=True)
def main(
    ctx: typer.Context,
    path: str = typer.Option(".", "--path", "-p", help="The root folder to scan."),
    depth: int = typer.Option(3, "--depth", "-d", show_default=True),
    languages: List[str] = typer.Option(
        (), "--lang", "-l", help="Filter tree to only include these extensions."
    ),
    inline: List[str] = typer.Option(
        (), "--inline", "-i", help="Extensions of scripts to print in full, e.g., .py"
    ),
    fmt: str = typer.Option(
        "text", "--format", "--fmt", "-f",
        case_sensitive=False, help="output format"
    ),
    output: Optional[Path] = typer.Option(
        None, "--output", "-o", help="write result to FILE instead of stdout",
        dir_okay=False,
    ),
    guide: bool = typer.Option(False, "--guide", "-g", help="step-by-step wizard"),
    menu: bool = typer.Option(False, "--menu", "-m", help="interactive menu"),
) -> None:
    """Entry point that delegates to command modules."""
    if guide or menu:
        (run_guide if guide else run_menu)(
            default_root=Path(path),
            default_depth=depth,
            default_format=fmt,
            default_output=output,
        )
        return

    if ctx.invoked_subcommand is None:
        generate_output(
            root=Path(path),
            depth=depth,
            fmt=fmt,
            output_path=output,
            languages=tuple(languages),
            inline_exts=tuple(inline)
        )

```

### 📄 src\oneclick_context\commands\generate.py

```
﻿"""
Generate a directory tree and send it to stdout or a file.
"""
from __future__ import annotations
from pathlib import Path
from typing import Optional, Tuple, List  # <-- Correctly import List
from rich.console import Console
from ..core import build_tree
from ..exporters import text, markdown, json as jsonexp, html

FMT_MAP = {
    "text": lambda t, p: "\n".join(text.render(t)),
    "md": markdown.render_md,
    "json": lambda t, p: jsonexp.render_json(t),
    "html": lambda t, p: html.render_html(t),
}

console = Console()

def _get_script_contents(root: Path, inline_exts: Tuple[str, ...]) -> str:
    """Finds, reads, and formats the content of specified script files."""
    output: List[str] = []
    
    extensions = {f".{ext.lstrip('.')}" for ext in inline_exts}
    
    files_to_inline = [p for p in sorted(root.rglob("*")) if p.is_file() and p.suffix in extensions]

    if not files_to_inline:
        return ""

    output.append(f"\n\n--- 📜 Scripts Content ({', '.join(inline_exts)}) ---\n")

    for file_path in files_to_inline:
        relative_path = file_path.relative_to(root)
        output.append(f"\n### 📄 {relative_path}\n")
        try:
            content = file_path.read_text(encoding="utf-8")
            output.append("```")
            output.append(content)
            output.append("```")
        except Exception as e:
            output.append(f"Could not read file: {e}")
    
    return "\n".join(output)

def generate_output(
    root: Path,
    depth: int,
    fmt: str,
    output_path: Optional[Path] = None,
    languages: Tuple[str, ...] = (),
    inline_exts: Tuple[str, ...] = (),
) -> None:
    """Build the tree, optionally inline scripts, and render it."""
    tree = build_tree(root=root, max_depth=depth, extra_exts=list(languages))
    rendered = FMT_MAP[fmt.lower()](tree, root)

    if inline_exts and fmt.lower() in ("text", "md"):
        script_content = _get_script_contents(root, inline_exts)
        rendered += script_content

    if output_path:
        dst = output_path.expanduser().resolve()
        dst.write_text(rendered, encoding="utf-8")
        console.print(f"[green]✓ Saved to [link={dst.as_uri()}]{dst}[/link][/green]")
    else:
        console.print(rendered)

```

### 📄 src\oneclick_context\core.py

```
﻿"""
Core helpers – build_tree()

Now supports:
• max_depth   – unchanged
• suppress    – skip folders by name (case-insensitive)
• extra_exts  – only include files whose suffix is in this allow-list
"""

from __future__ import annotations

from pathlib import Path
from typing import TypedDict, List, Optional, Set


class Node(TypedDict):
    type: str         # "file" | "dir"
    name: str
    children: List["Node"]


def build_tree(
    root: Path,
    *,
    max_depth: int = 3,
    suppress: Optional[List[str]] = None,
    extra_exts: Optional[List[str]] = None,
    _depth: int = 0,
) -> Node:
    """Return a nested dict representing *root*’s directory tree."""

    suppress_set: Set[str] = {s.lower() for s in (suppress or [])}
    ext_filter: Optional[Set[str]] = (
        {e if e.startswith(".") else f".{e}" for e in extra_exts} if extra_exts else None
    )

    node: Node = {"type": "dir", "name": root.name, "children": []}

    if _depth >= max_depth:
        return node

    try:
        # dirs first, then files; both alphabetically case-insensitive
        entries = sorted(root.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))
    except PermissionError:  # unreadable dir – skip silently
        return node

    for entry in entries:
        if entry.is_dir():
            if entry.name.lower() in suppress_set:
                continue
            node["children"].append(
                build_tree(
                    entry,
                    max_depth=max_depth,
                    suppress=suppress,
                    extra_exts=extra_exts,
                    _depth=_depth + 1,
                )
            )
        elif entry.is_file():
            if ext_filter and entry.suffix not in ext_filter:
                continue
            node["children"].append(
                {"type": "file", "name": entry.name, "children": []}
            )

    return node

```

### 📄 src\oneclick_context\exporters\__init__.py

```
﻿from . import text, markdown, json, html  # noqa: F401

```

### 📄 src\oneclick_context\exporters\html.py

```
﻿def _render_li(node):
    if node["type"] == "file":
        return f"<li>{node['name']}</li>"
    children_html = "".join(_render_li(c) for c in node["children"])
    return f"<li><details><summary>{node['name']}</summary><ul>{children_html}</ul></details></li>"

def render_html(tree_obj):
    return f"<ul>{_render_li(tree_obj)}</ul>"

```

### 📄 src\oneclick_context\exporters\json.py

```
﻿import json
def render_json(tree_obj):
    return json.dumps(tree_obj, indent=2)

```

### 📄 src\oneclick_context\exporters\markdown.py

```
﻿from pathlib import Path
from .text import render

def render_md(tree_obj, folder: Path):
    body = "\n".join(render(tree_obj))
    name = folder.name or str(folder)
    return (
        f"<details><summary>📁 {name}</summary>\n\n"
        "```text\n"
        f"{body}\n"
        "```\n"
        "</details>"
    )

```

### 📄 src\oneclick_context\exporters\text.py

```
﻿TEE, CORNER, PIPE, SPACE = "├──", "└──", "│   ", "    "

def render(node, prefix=""):
    lines = []
    children = node["children"]
    pointers = [TEE] * (len(children) - 1) + [CORNER]
    for pointer, child in zip(pointers, children):
        lines.append(f"{prefix}{pointer} {child['name']}")
        if child["type"] == "dir":
            extension = PIPE if pointer == TEE else SPACE
            lines.extend(render(child, prefix + extension))
    return lines

```

### 📄 src\oneclick_context\prompts.py

```
﻿# Standard library imports
import os
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

# Third-party imports
import questionary as q
try:
    from questionary import QuestionaryError
except ImportError:
    class QuestionaryError(Exception): pass

# First-party imports
from .commands.generate import generate_output
from .utils import discover_extensions, sanitize_path

# --- Constants ---
COMMON_LIBS = ["node_modules", "dist", ".venv", ".git", "__pycache__"]
SAVE_DIR_ENV_VAR = "ONECLICK_SAVE_DIR"
CONFIG_FILE = Path.home() / ".oneclick_rc.json"
SEPARATOR = ("-" * 20, "fg:#888888")

# --- Internal Helpers ---
def _abort_if_none(val):
    if val is None: raise QuestionaryError("User cancelled.")
    return val

def _ask_tree_params(root_path: Path, defaults: Dict[str, Any]) -> Dict[str, Any]:
    while True:
        depth_str = _abort_if_none(q.text("📏 Max recursion depth:", default=str(defaults.get("depth", 3))).ask())
        try:
            depth = int(depth_str)
            if depth > 0: break
            q.print("Please enter a positive number.", style="bold yellow")
        except (ValueError, AssertionError):
            q.print("Please enter a valid integer.", style="bold yellow")
    languages: List[str] = []
    if _abort_if_none(q.confirm("🔍 Filter by specific file types?", default=False).ask()):
        all_exts = discover_extensions(root_path, suppress=COMMON_LIBS)
        if all_exts:
            languages = _abort_if_none(q.checkbox("   Select extensions:", choices=sorted(all_exts)).ask())
    fmt = _abort_if_none(q.select("🎨 Output format:", choices=["text", "md", "json", "html"], default=defaults.get("fmt", "text")).ask())
    return {"depth": depth, "languages": tuple(languages), "fmt": fmt}

def _load_config() -> Optional[Path]:
    """Load the save directory from environment or config file."""
    # 1. Check environment variable (highest priority)
    env_path_str = os.getenv(SAVE_DIR_ENV_VAR)
    if env_path_str:
        try:
            expanded_path = os.path.expandvars(env_path_str)
            path = sanitize_path(expanded_path)
            path.mkdir(parents=True, exist_ok=True)
            return path
        except (OSError, PermissionError) as exc:
            q.print(f"⚠️  Could not use env var {SAVE_DIR_ENV_VAR}='{env_path_str}': {exc}", style="bold yellow")
    
    # 2. If no env var, check config file
    if CONFIG_FILE.is_file():
        try:
            with CONFIG_FILE.open("r") as f:
                data = json.load(f)
                path_str = data.get("save_dir")
                if path_str:
                    path = sanitize_path(path_str)
                    path.mkdir(parents=True, exist_ok=True)
                    return path
        except (json.JSONDecodeError, OSError, PermissionError) as exc:
             q.print(f"⚠️  Could not load config file at '{CONFIG_FILE}': {exc}", style="bold yellow")
    return None

def _save_config(save_dir: Optional[Path]) -> None:
    """Save the current save directory to the config file."""
    try:
        with CONFIG_FILE.open("w") as f:
            json.dump({"save_dir": str(save_dir) if save_dir else None}, f, indent=2)
    except OSError as exc:
        q.print(f"⚠️  Could not save to config file '{CONFIG_FILE}': {exc}", style="bold yellow")


# --- Public Interface (called by cli.py) ---
def run_guide(default_root: Path, default_depth: int, default_format: str, default_output: Optional[Path]) -> None:
    try:
        path_str = _abort_if_none(q.path("📁 1. Directory to scan:", default=str(default_root)).ask())
        root_path = sanitize_path(path_str)
        params = _ask_tree_params(root_path, {"depth": default_depth, "fmt": default_format})
        output_str = _abort_if_none(q.text("💾 2. Save to file? (leave blank for console)", default=str(default_output or "")).ask())
        output_path = sanitize_path(output_str) if output_str.strip() else None
        q.print("\n⏳ Generating your tree...", style="bold")
        generate_output(root=root_path, output_path=output_path, **params)
        if not output_path:
            q.print("\n✨ Done!", style="bold green")
        q.print(SEPARATOR[0], style=SEPARATOR[1])
    except (QuestionaryError, KeyboardInterrupt):
        q.print("\nOperation cancelled.", style="bold red")
        sys.exit(0)
    except Exception as e:
        q.print(f"\nAn unexpected error occurred: {e}", style="bold red")
        sys.exit(1)

def run_menu(*args, **kwargs) -> None:
    save_dir = _load_config()
    try:
        q.print("Welcome to One-Click Context Menu Mode!", style="bold italic")
        if save_dir:
            q.print(f"Loaded save directory: {save_dir}", style="fg:#888888")

        while True:
            action = _abort_if_none(q.select(
                "📂 Main Menu:",
                choices=[
                    q.Choice("🌳 Generate New Tree", value="generate"),
                    q.Choice(f"💾 Set/Change Save Directory (persists)", value="config"),
                    q.Separator(),
                    q.Choice("Exit", value="exit")
                ], use_indicator=True).ask())

            if action == "exit": break

            elif action == "config":
                path_str = _abort_if_none(q.path("Enter directory to save files in (leave blank to clear):", default=str(save_dir or "")).ask())
                new_save_dir = None
                if path_str.strip():
                    try:
                        new_save_dir = sanitize_path(path_str)
                        new_save_dir.mkdir(parents=True, exist_ok=True)
                        q.print(f"✅ Save directory set to: {new_save_dir}", style="bold green")
                    except (OSError, PermissionError) as exc:
                        new_save_dir = None
                        q.print(f"❌ Cannot use that directory: {exc}", style="bold red")
                else:
                    q.print("✅ Save directory cleared.", style="bold green")

                save_dir = new_save_dir
                _save_config(save_dir)

            elif action == "generate":
                path_str = _abort_if_none(q.path("📁 Directory to scan:", default=".").ask())
                root_path = sanitize_path(path_str)
                params = _ask_tree_params(root_path, {})
                
                output_path = None
                if save_dir:
                    ts = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]
                    ext = "txt" if params["fmt"] == "text" else params["fmt"]
                    output_path = save_dir / f"tree_{ts}.{ext}"
                
                q.print("\n⏳ Generating your tree...", style="bold")
                generate_output(root=root_path, output_path=output_path, **params)
                
                if not output_path:
                    q.print("\n✨ Done!", style="bold green")
                q.print(SEPARATOR[0], style=SEPARATOR[1])
    
    except (QuestionaryError, KeyboardInterrupt):
        q.print("\n\nGoodbye!", style="bold")
        sys.exit(0)
    except Exception as e:
        q.print(f"\nAn unexpected error occurred: {e}", style="bold red")
        sys.exit(1)

```

### 📄 src\oneclick_context\utils.py

```
﻿from pathlib import Path
from typing import Optional
import inspect, click, typer

COMMON_LIBS = ["node_modules", "dist", ".venv", ".git", "__pycache__"]

def _abort_if_none(val):
    """Exit CLI (code 0) when Questionary returns None (Esc / Ctrl-C)."""
    if val is None:
        raise typer.Exit()
    return val

def sanitize_path(raw: Optional[str]) -> Path:
    """
    Return absolute Path from user input.
    If *raw* is None/blank → current working directory.
    """
    if raw is None or not str(raw).strip():
        return Path.cwd()
    return (
        Path(str(raw).strip().lstrip("./").strip('"'))
        .expanduser()
        .resolve()
    )

def discover_extensions(root: Path, suppress: list[str]) -> list[str]:
    """
    Return a sorted list of unique file suffixes ('.py', '.ts', …)
    under *root*, skipping suppressed directories.
    """
    suppress_lc = {s.lower() for s in suppress}
    exts: set[str] = set()
    for p in root.rglob("*"):
        if not p.is_file() or not p.suffix:
            continue
        if any(part.lower() in suppress_lc for part in p.parts):
            continue
        exts.add(p.suffix)
    return sorted(exts, key=str.lower)


SUPPORTS_HYPERLINK = "hyperlink" in inspect.signature(click.style).parameters

```

### 📄 tests\__init__.py

```

```

### 📄 tests\test_cli.py

```
﻿from pathlib import Path
from typer.testing import CliRunner

from oneclick_context.cli import app

runner = CliRunner()

def test_json_output(tmp_path: Path):
    (tmp_path / "sub").mkdir()
    (tmp_path / "sub" / "a.txt").write_text("x")
    
    # The test now correctly calls the named --path option.
    result = runner.invoke(
        app, ["--path", str(tmp_path), "--fmt", "json"]
    )
    
    assert result.exit_code == 0, f"CLI exited with an error:\n{result.stdout}\n{result.stderr}"
    assert result.exception is None
    assert '"a.txt"' in result.stdout

def test_language_filter(tmp_path: Path):
    """Verify that the --lang flag correctly filters files by extension."""
    # Create a test structure with different file types
    (tmp_path / "a.py").write_text("python")
    (tmp_path / "b.js").write_text("javascript")
    (tmp_path / "c.toml").write_text("toml")

    # Run the command with filters for .py and .toml
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--lang", ".py",
        "--lang", ".toml"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains the desired files
    assert "a.py" in result.stdout
    assert "c.toml" in result.stdout

    # Assert that the filtered-out file is NOT in the output
    assert "b.js" not in result.stdout

def test_markdown_output(tmp_path: Path):
    """Verify that the --format md flag produces a collapsible Markdown block."""
    # Create a dummy file in the temp directory
    (tmp_path / "file.txt").write_text("content")

    # Run the command to generate Markdown output
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--format", "md"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains the key elements of our Markdown format
    assert "<details><summary>" in result.stdout
    assert "```text" in result.stdout
    assert "file.txt" in result.stdout
    assert "```" in result.stdout
    assert "</details>" in result.stdout

def test_html_output(tmp_path: Path):
    """Verify that the --format html flag produces a collapsible HTML list."""
    # Create a dummy file in the temp directory
    (tmp_path / "file.txt").write_text("content")

    # Run the command to generate HTML output
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--format", "html"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains key HTML tags for a nested list
    assert "<ul>" in result.stdout
    assert "<li>" in result.stdout
    assert "<details><summary>" in result.stdout
    assert "file.txt" in result.stdout
    assert "</details>" in result.stdout
    assert "</ul>" in result.stdout

```

### 📄 tests\test_prompts.py

```
﻿# tests/test_prompts.py
import sys
from pathlib import Path
from unittest.mock import MagicMock

import pytest
import questionary as q

# Correctly import the specific exception class for modern versions,
# with a fallback for older ones.
try:
    from questionary import QuestionaryError
except ImportError:
    class QuestionaryError(Exception):
        pass

from oneclick_context.prompts import run_guide

# ── helpers ─────────────────────────────────────────────────────────────
class Stub:
    """Minimal object mimicking a Questionary prompt: .ask() -> value."""
    def __init__(self, value):
        self._value = value

    def ask(self):
        if self._value is None:
            raise QuestionaryError("User cancelled.")
        return self._value

def make_stub_sequence(answers):
    """Return a function that pops answers in FIFO order each call."""
    queue = list(answers)
    def _factory(*_args, **_kwargs):
        if not queue:
            raise AssertionError("Test stub queue exhausted. More prompts were called than answers provided.")
        return Stub(queue.pop(0))
    return _factory

# ── tests ───────────────────────────────────────────────────────────────
def test_run_guide_happy_path(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """End-to-end test of the interactive guide using Questionary stubs."""
    answers = [
        str(tmp_path), "2", True, [".py", ".md"], "md", str(tmp_path / "output.md"),
    ]

    stub_factory = make_stub_sequence(answers)
    monkeypatch.setattr("questionary.path", stub_factory)
    monkeypatch.setattr("questionary.text", stub_factory)
    monkeypatch.setattr("questionary.confirm", stub_factory)
    monkeypatch.setattr("questionary.checkbox", stub_factory)
    monkeypatch.setattr("questionary.select", stub_factory)

    # Mock the print function to prevent console errors during test runs
    monkeypatch.setattr("questionary.print", MagicMock())
    
    monkeypatch.setattr("oneclick_context.prompts.discover_extensions", lambda *args, **kwargs: [".py", ".md", ".js"])

    mock_generate = MagicMock()
    monkeypatch.setattr("oneclick_context.prompts.generate_output", mock_generate)

    run_guide(default_root=tmp_path, default_depth=3, default_format="text", default_output=None)

    mock_generate.assert_called_once()
    kwargs = mock_generate.call_args.kwargs
    assert kwargs["root"] == tmp_path
    assert kwargs["depth"] == 2
    assert kwargs["fmt"] == "md"
    assert kwargs["output_path"] == tmp_path / "output.md"
    assert kwargs["languages"] == (".py", ".md")

```

### 📄 tests\test_smoke.py

```
﻿def test_smoke():
    assert True

```