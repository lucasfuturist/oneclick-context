<details><summary>ğŸ“ .</summary>

```text
â”œâ”€â”€ .git
â”‚   â”œâ”€â”€ hooks
â”‚   â”‚   â”œâ”€â”€ applypatch-msg.sample
â”‚   â”‚   â”œâ”€â”€ commit-msg.sample
â”‚   â”‚   â”œâ”€â”€ fsmonitor-watchman.sample
â”‚   â”‚   â”œâ”€â”€ post-update.sample
â”‚   â”‚   â”œâ”€â”€ pre-applypatch.sample
â”‚   â”‚   â”œâ”€â”€ pre-commit.sample
â”‚   â”‚   â”œâ”€â”€ pre-merge-commit.sample
â”‚   â”‚   â”œâ”€â”€ pre-push.sample
â”‚   â”‚   â”œâ”€â”€ pre-rebase.sample
â”‚   â”‚   â”œâ”€â”€ pre-receive.sample
â”‚   â”‚   â”œâ”€â”€ prepare-commit-msg.sample
â”‚   â”‚   â”œâ”€â”€ push-to-checkout.sample
â”‚   â”‚   â”œâ”€â”€ sendemail-validate.sample
â”‚   â”‚   â””â”€â”€ update.sample
â”‚   â”œâ”€â”€ info
â”‚   â”‚   â””â”€â”€ exclude
â”‚   â”œâ”€â”€ logs
â”‚   â”‚   â”œâ”€â”€ refs
â”‚   â”‚   â””â”€â”€ HEAD
â”‚   â”œâ”€â”€ objects
â”‚   â”‚   â”œâ”€â”€ 01
â”‚   â”‚   â”œâ”€â”€ 02
â”‚   â”‚   â”œâ”€â”€ 06
â”‚   â”‚   â”œâ”€â”€ 07
â”‚   â”‚   â”œâ”€â”€ 0b
â”‚   â”‚   â”œâ”€â”€ 0c
â”‚   â”‚   â”œâ”€â”€ 0e
â”‚   â”‚   â”œâ”€â”€ 10
â”‚   â”‚   â”œâ”€â”€ 14
â”‚   â”‚   â”œâ”€â”€ 15
â”‚   â”‚   â”œâ”€â”€ 16
â”‚   â”‚   â”œâ”€â”€ 18
â”‚   â”‚   â”œâ”€â”€ 19
â”‚   â”‚   â”œâ”€â”€ 1b
â”‚   â”‚   â”œâ”€â”€ 1c
â”‚   â”‚   â”œâ”€â”€ 20
â”‚   â”‚   â”œâ”€â”€ 21
â”‚   â”‚   â”œâ”€â”€ 22
â”‚   â”‚   â”œâ”€â”€ 23
â”‚   â”‚   â”œâ”€â”€ 24
â”‚   â”‚   â”œâ”€â”€ 25
â”‚   â”‚   â”œâ”€â”€ 29
â”‚   â”‚   â”œâ”€â”€ 2a
â”‚   â”‚   â”œâ”€â”€ 2b
â”‚   â”‚   â”œâ”€â”€ 2f
â”‚   â”‚   â”œâ”€â”€ 33
â”‚   â”‚   â”œâ”€â”€ 37
â”‚   â”‚   â”œâ”€â”€ 38
â”‚   â”‚   â”œâ”€â”€ 39
â”‚   â”‚   â”œâ”€â”€ 3a
â”‚   â”‚   â”œâ”€â”€ 3b
â”‚   â”‚   â”œâ”€â”€ 3c
â”‚   â”‚   â”œâ”€â”€ 3d
â”‚   â”‚   â”œâ”€â”€ 3e
â”‚   â”‚   â”œâ”€â”€ 41
â”‚   â”‚   â”œâ”€â”€ 42
â”‚   â”‚   â”œâ”€â”€ 44
â”‚   â”‚   â”œâ”€â”€ 45
â”‚   â”‚   â”œâ”€â”€ 47
â”‚   â”‚   â”œâ”€â”€ 48
â”‚   â”‚   â”œâ”€â”€ 4a
â”‚   â”‚   â”œâ”€â”€ 4b
â”‚   â”‚   â”œâ”€â”€ 4d
â”‚   â”‚   â”œâ”€â”€ 4e
â”‚   â”‚   â”œâ”€â”€ 52
â”‚   â”‚   â”œâ”€â”€ 53
â”‚   â”‚   â”œâ”€â”€ 54
â”‚   â”‚   â”œâ”€â”€ 55
â”‚   â”‚   â”œâ”€â”€ 57
â”‚   â”‚   â”œâ”€â”€ 5c
â”‚   â”‚   â”œâ”€â”€ 61
â”‚   â”‚   â”œâ”€â”€ 62
â”‚   â”‚   â”œâ”€â”€ 63
â”‚   â”‚   â”œâ”€â”€ 67
â”‚   â”‚   â”œâ”€â”€ 68
â”‚   â”‚   â”œâ”€â”€ 69
â”‚   â”‚   â”œâ”€â”€ 6c
â”‚   â”‚   â”œâ”€â”€ 6d
â”‚   â”‚   â”œâ”€â”€ 6e
â”‚   â”‚   â”œâ”€â”€ 6f
â”‚   â”‚   â”œâ”€â”€ 70
â”‚   â”‚   â”œâ”€â”€ 71
â”‚   â”‚   â”œâ”€â”€ 74
â”‚   â”‚   â”œâ”€â”€ 77
â”‚   â”‚   â”œâ”€â”€ 7b
â”‚   â”‚   â”œâ”€â”€ 7e
â”‚   â”‚   â”œâ”€â”€ 80
â”‚   â”‚   â”œâ”€â”€ 81
â”‚   â”‚   â”œâ”€â”€ 82
â”‚   â”‚   â”œâ”€â”€ 84
â”‚   â”‚   â”œâ”€â”€ 85
â”‚   â”‚   â”œâ”€â”€ 87
â”‚   â”‚   â”œâ”€â”€ 8b
â”‚   â”‚   â”œâ”€â”€ 8c
â”‚   â”‚   â”œâ”€â”€ 8d
â”‚   â”‚   â”œâ”€â”€ 8e
â”‚   â”‚   â”œâ”€â”€ 8f
â”‚   â”‚   â”œâ”€â”€ 94
â”‚   â”‚   â”œâ”€â”€ 95
â”‚   â”‚   â”œâ”€â”€ 96
â”‚   â”‚   â”œâ”€â”€ 97
â”‚   â”‚   â”œâ”€â”€ 98
â”‚   â”‚   â”œâ”€â”€ 99
â”‚   â”‚   â”œâ”€â”€ 9a
â”‚   â”‚   â”œâ”€â”€ 9d
â”‚   â”‚   â”œâ”€â”€ 9f
â”‚   â”‚   â”œâ”€â”€ a2
â”‚   â”‚   â”œâ”€â”€ a3
â”‚   â”‚   â”œâ”€â”€ a4
â”‚   â”‚   â”œâ”€â”€ a5
â”‚   â”‚   â”œâ”€â”€ a6
â”‚   â”‚   â”œâ”€â”€ a7
â”‚   â”‚   â”œâ”€â”€ a9
â”‚   â”‚   â”œâ”€â”€ ac
â”‚   â”‚   â”œâ”€â”€ af
â”‚   â”‚   â”œâ”€â”€ b3
â”‚   â”‚   â”œâ”€â”€ b4
â”‚   â”‚   â”œâ”€â”€ b6
â”‚   â”‚   â”œâ”€â”€ b7
â”‚   â”‚   â”œâ”€â”€ b8
â”‚   â”‚   â”œâ”€â”€ ba
â”‚   â”‚   â”œâ”€â”€ bc
â”‚   â”‚   â”œâ”€â”€ bd
â”‚   â”‚   â”œâ”€â”€ be
â”‚   â”‚   â”œâ”€â”€ bf
â”‚   â”‚   â”œâ”€â”€ c0
â”‚   â”‚   â”œâ”€â”€ c1
â”‚   â”‚   â”œâ”€â”€ c2
â”‚   â”‚   â”œâ”€â”€ c3
â”‚   â”‚   â”œâ”€â”€ c4
â”‚   â”‚   â”œâ”€â”€ c5
â”‚   â”‚   â”œâ”€â”€ c8
â”‚   â”‚   â”œâ”€â”€ c9
â”‚   â”‚   â”œâ”€â”€ cb
â”‚   â”‚   â”œâ”€â”€ cd
â”‚   â”‚   â”œâ”€â”€ ce
â”‚   â”‚   â”œâ”€â”€ cf
â”‚   â”‚   â”œâ”€â”€ d1
â”‚   â”‚   â”œâ”€â”€ d2
â”‚   â”‚   â”œâ”€â”€ d4
â”‚   â”‚   â”œâ”€â”€ d5
â”‚   â”‚   â”œâ”€â”€ d6
â”‚   â”‚   â”œâ”€â”€ d7
â”‚   â”‚   â”œâ”€â”€ d8
â”‚   â”‚   â”œâ”€â”€ da
â”‚   â”‚   â”œâ”€â”€ db
â”‚   â”‚   â”œâ”€â”€ dc
â”‚   â”‚   â”œâ”€â”€ dd
â”‚   â”‚   â”œâ”€â”€ de
â”‚   â”‚   â”œâ”€â”€ e0
â”‚   â”‚   â”œâ”€â”€ e1
â”‚   â”‚   â”œâ”€â”€ e2
â”‚   â”‚   â”œâ”€â”€ e5
â”‚   â”‚   â”œâ”€â”€ e6
â”‚   â”‚   â”œâ”€â”€ e8
â”‚   â”‚   â”œâ”€â”€ e9
â”‚   â”‚   â”œâ”€â”€ eb
â”‚   â”‚   â”œâ”€â”€ ec
â”‚   â”‚   â”œâ”€â”€ ed
â”‚   â”‚   â”œâ”€â”€ ee
â”‚   â”‚   â”œâ”€â”€ ef
â”‚   â”‚   â”œâ”€â”€ f0
â”‚   â”‚   â”œâ”€â”€ f2
â”‚   â”‚   â”œâ”€â”€ f3
â”‚   â”‚   â”œâ”€â”€ f4
â”‚   â”‚   â”œâ”€â”€ f5
â”‚   â”‚   â”œâ”€â”€ f6
â”‚   â”‚   â”œâ”€â”€ f7
â”‚   â”‚   â”œâ”€â”€ f9
â”‚   â”‚   â”œâ”€â”€ fb
â”‚   â”‚   â”œâ”€â”€ fc
â”‚   â”‚   â”œâ”€â”€ fd
â”‚   â”‚   â”œâ”€â”€ ff
â”‚   â”‚   â”œâ”€â”€ info
â”‚   â”‚   â””â”€â”€ pack
â”‚   â”œâ”€â”€ refs
â”‚   â”‚   â”œâ”€â”€ heads
â”‚   â”‚   â”œâ”€â”€ remotes
â”‚   â”‚   â””â”€â”€ tags
â”‚   â”œâ”€â”€ COMMIT_EDITMSG
â”‚   â”œâ”€â”€ config
â”‚   â”œâ”€â”€ description
â”‚   â”œâ”€â”€ HEAD
â”‚   â””â”€â”€ index
â”œâ”€â”€ .github
â”‚   â””â”€â”€ workflows
â”‚       â”œâ”€â”€ ci.yml
â”‚       â””â”€â”€ release.yml
â”œâ”€â”€ .pytest_cache
â”‚   â”œâ”€â”€ v
â”‚   â”‚   â””â”€â”€ cache
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ CACHEDIR.TAG
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ dev-utils
â”‚   â”œâ”€â”€ oneclick
â”‚   â”‚   â””â”€â”€ tree_20250724_181742_113.json
â”‚   â”œâ”€â”€ tree_20250724_185245_335.html
â”‚   â””â”€â”€ tree_20250724_185958_151.html
â”œâ”€â”€ dist
â”‚   â”œâ”€â”€ oneclick_context-0.1.2-py3-none-any.whl
â”‚   â”œâ”€â”€ oneclick_context-0.1.2.tar.gz
â”‚   â”œâ”€â”€ oneclick_context-0.2.2-py3-none-any.whl
â”‚   â”œâ”€â”€ oneclick_context-0.2.2.tar.gz
â”‚   â”œâ”€â”€ oneclick_context-0.2.4-py3-none-any.whl
â”‚   â””â”€â”€ oneclick_context-0.2.4.tar.gz
â”œâ”€â”€ src
â”‚   â””â”€â”€ oneclick_context
â”‚       â”œâ”€â”€ __pycache__
â”‚       â”œâ”€â”€ commands
â”‚       â”œâ”€â”€ exporters
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ cli.py
â”‚       â”œâ”€â”€ core.py
â”‚       â”œâ”€â”€ prompts.py
â”‚       â””â”€â”€ utils.py
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ __pycache__
â”‚   â”‚   â”œâ”€â”€ __init__.cpython-313.pyc
â”‚   â”‚   â”œâ”€â”€ test_cli.cpython-313-pytest-8.4.1.pyc
â”‚   â”‚   â”œâ”€â”€ test_prompts.cpython-313-pytest-8.4.1.pyc
â”‚   â”‚   â””â”€â”€ test_smoke.cpython-313-pytest-8.4.1.pyc
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_cli.py
â”‚   â”œâ”€â”€ test_prompts.py
â”‚   â””â”€â”€ test_smoke.py
â”œâ”€â”€ .gitignore
â”œâ”€â”€ all_python_sources.md
â”œâ”€â”€ CHANGELOG.md
â”œâ”€â”€ poetry.lock
â”œâ”€â”€ prompts.bak
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ test_prompts.bak
â””â”€â”€ tree.md
```
</details>

--- ğŸ“œ Scripts Content (.py) ---


### ğŸ“„ src\oneclick_context\__init__.py

```

```

### ğŸ“„ src\oneclick_context\cli.py

```
ï»¿# Standard library imports
from pathlib import Path
from typing import Optional, List

# Third-party imports
import typer

# First-party imports
from .commands.generate import generate_output
from .prompts import run_guide, run_menu

app = typer.Typer(add_completion=False, help="Generate compact file trees")

@app.callback(invoke_without_command=True)
def main(
    ctx: typer.Context,
    path: str = typer.Option(".", "--path", "-p", help="The root folder to scan."),
    depth: int = typer.Option(3, "--depth", "-d", show_default=True),
    languages: List[str] = typer.Option(
        (), "--lang", "-l", help="Filter tree to only include these extensions."
    ),
    inline: List[str] = typer.Option(
        (), "--inline", "-i", help="Extensions of scripts to print in full, e.g., .py"
    ),
    fmt: str = typer.Option(
        "text", "--format", "--fmt", "-f",
        case_sensitive=False, help="output format"
    ),
    output: Optional[Path] = typer.Option(
        None, "--output", "-o", help="write result to FILE instead of stdout",
        dir_okay=False,
    ),
    guide: bool = typer.Option(False, "--guide", "-g", help="step-by-step wizard"),
    menu: bool = typer.Option(False, "--menu", "-m", help="interactive menu"),
) -> None:
    """Entry point that delegates to command modules."""
    if guide or menu:
        (run_guide if guide else run_menu)(
            default_root=Path(path),
            default_depth=depth,
            default_format=fmt,
            default_output=output,
        )
        return

    if ctx.invoked_subcommand is None:
        generate_output(
            root=Path(path),
            depth=depth,
            fmt=fmt,
            output_path=output,
            languages=tuple(languages),
            inline_exts=tuple(inline)
        )

```

### ğŸ“„ src\oneclick_context\commands\generate.py

```
ï»¿"""
Generate a directory tree and send it to stdout or a file.
"""
from __future__ import annotations
from pathlib import Path
from typing import Optional, Tuple, List  # <-- Correctly import List
from rich.console import Console
from ..core import build_tree
from ..exporters import text, markdown, json as jsonexp, html

FMT_MAP = {
    "text": lambda t, p: "\n".join(text.render(t)),
    "md": markdown.render_md,
    "json": lambda t, p: jsonexp.render_json(t),
    "html": lambda t, p: html.render_html(t),
}

console = Console()

def _get_script_contents(root: Path, inline_exts: Tuple[str, ...]) -> str:
    """Finds, reads, and formats the content of specified script files."""
    output: List[str] = []
    
    extensions = {f".{ext.lstrip('.')}" for ext in inline_exts}
    
    files_to_inline = [p for p in sorted(root.rglob("*")) if p.is_file() and p.suffix in extensions]

    if not files_to_inline:
        return ""

    output.append(f"\n\n--- ğŸ“œ Scripts Content ({', '.join(inline_exts)}) ---\n")

    for file_path in files_to_inline:
        relative_path = file_path.relative_to(root)
        output.append(f"\n### ğŸ“„ {relative_path}\n")
        try:
            content = file_path.read_text(encoding="utf-8")
            output.append("```")
            output.append(content)
            output.append("```")
        except Exception as e:
            output.append(f"Could not read file: {e}")
    
    return "\n".join(output)

def generate_output(
    root: Path,
    depth: int,
    fmt: str,
    output_path: Optional[Path] = None,
    languages: Tuple[str, ...] = (),
    inline_exts: Tuple[str, ...] = (),
) -> None:
    """Build the tree, optionally inline scripts, and render it."""
    tree = build_tree(root=root, max_depth=depth, extra_exts=list(languages))
    rendered = FMT_MAP[fmt.lower()](tree, root)

    if inline_exts and fmt.lower() in ("text", "md"):
        script_content = _get_script_contents(root, inline_exts)
        rendered += script_content

    if output_path:
        dst = output_path.expanduser().resolve()
        dst.write_text(rendered, encoding="utf-8")
        console.print(f"[green]âœ“ Saved to [link={dst.as_uri()}]{dst}[/link][/green]")
    else:
        console.print(rendered)

```

### ğŸ“„ src\oneclick_context\core.py

```
ï»¿"""
Core helpers â€“ build_tree()

Now supports:
â€¢ max_depth   â€“ unchanged
â€¢ suppress    â€“ skip folders by name (case-insensitive)
â€¢ extra_exts  â€“ only include files whose suffix is in this allow-list
"""

from __future__ import annotations

from pathlib import Path
from typing import TypedDict, List, Optional, Set


class Node(TypedDict):
    type: str         # "file" | "dir"
    name: str
    children: List["Node"]


def build_tree(
    root: Path,
    *,
    max_depth: int = 3,
    suppress: Optional[List[str]] = None,
    extra_exts: Optional[List[str]] = None,
    _depth: int = 0,
) -> Node:
    """Return a nested dict representing *root*â€™s directory tree."""

    suppress_set: Set[str] = {s.lower() for s in (suppress or [])}
    ext_filter: Optional[Set[str]] = (
        {e if e.startswith(".") else f".{e}" for e in extra_exts} if extra_exts else None
    )

    node: Node = {"type": "dir", "name": root.name, "children": []}

    if _depth >= max_depth:
        return node

    try:
        # dirs first, then files; both alphabetically case-insensitive
        entries = sorted(root.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))
    except PermissionError:  # unreadable dir â€“ skip silently
        return node

    for entry in entries:
        if entry.is_dir():
            if entry.name.lower() in suppress_set:
                continue
            node["children"].append(
                build_tree(
                    entry,
                    max_depth=max_depth,
                    suppress=suppress,
                    extra_exts=extra_exts,
                    _depth=_depth + 1,
                )
            )
        elif entry.is_file():
            if ext_filter and entry.suffix not in ext_filter:
                continue
            node["children"].append(
                {"type": "file", "name": entry.name, "children": []}
            )

    return node

```

### ğŸ“„ src\oneclick_context\exporters\__init__.py

```
ï»¿from . import text, markdown, json, html  # noqa: F401

```

### ğŸ“„ src\oneclick_context\exporters\html.py

```
ï»¿def _render_li(node):
    if node["type"] == "file":
        return f"<li>{node['name']}</li>"
    children_html = "".join(_render_li(c) for c in node["children"])
    return f"<li><details><summary>{node['name']}</summary><ul>{children_html}</ul></details></li>"

def render_html(tree_obj):
    return f"<ul>{_render_li(tree_obj)}</ul>"

```

### ğŸ“„ src\oneclick_context\exporters\json.py

```
ï»¿import json
def render_json(tree_obj):
    return json.dumps(tree_obj, indent=2)

```

### ğŸ“„ src\oneclick_context\exporters\markdown.py

```
ï»¿from pathlib import Path
from .text import render

def render_md(tree_obj, folder: Path):
    body = "\n".join(render(tree_obj))
    name = folder.name or str(folder)
    return (
        f"<details><summary>ğŸ“ {name}</summary>\n\n"
        "```text\n"
        f"{body}\n"
        "```\n"
        "</details>"
    )

```

### ğŸ“„ src\oneclick_context\exporters\text.py

```
ï»¿TEE, CORNER, PIPE, SPACE = "â”œâ”€â”€", "â””â”€â”€", "â”‚   ", "    "

def render(node, prefix=""):
    lines = []
    children = node["children"]
    pointers = [TEE] * (len(children) - 1) + [CORNER]
    for pointer, child in zip(pointers, children):
        lines.append(f"{prefix}{pointer} {child['name']}")
        if child["type"] == "dir":
            extension = PIPE if pointer == TEE else SPACE
            lines.extend(render(child, prefix + extension))
    return lines

```

### ğŸ“„ src\oneclick_context\prompts.py

```
ï»¿# Standard library imports
import os
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

# Third-party imports
import questionary as q
try:
    from questionary import QuestionaryError
except ImportError:
    class QuestionaryError(Exception): pass

# First-party imports
from .commands.generate import generate_output
from .utils import discover_extensions, sanitize_path

# --- Constants ---
COMMON_LIBS = ["node_modules", "dist", ".venv", ".git", "__pycache__"]
SAVE_DIR_ENV_VAR = "ONECLICK_SAVE_DIR"
CONFIG_FILE = Path.home() / ".oneclick_rc.json"
SEPARATOR = ("-" * 20, "fg:#888888")

# --- Internal Helpers ---
def _abort_if_none(val):
    if val is None: raise QuestionaryError("User cancelled.")
    return val

def _ask_tree_params(root_path: Path, defaults: Dict[str, Any]) -> Dict[str, Any]:
    while True:
        depth_str = _abort_if_none(q.text("ğŸ“ Max recursion depth:", default=str(defaults.get("depth", 3))).ask())
        try:
            depth = int(depth_str)
            if depth > 0: break
            q.print("Please enter a positive number.", style="bold yellow")
        except (ValueError, AssertionError):
            q.print("Please enter a valid integer.", style="bold yellow")
    languages: List[str] = []
    if _abort_if_none(q.confirm("ğŸ” Filter by specific file types?", default=False).ask()):
        all_exts = discover_extensions(root_path, suppress=COMMON_LIBS)
        if all_exts:
            languages = _abort_if_none(q.checkbox("   Select extensions:", choices=sorted(all_exts)).ask())
    fmt = _abort_if_none(q.select("ğŸ¨ Output format:", choices=["text", "md", "json", "html"], default=defaults.get("fmt", "text")).ask())
    return {"depth": depth, "languages": tuple(languages), "fmt": fmt}

def _load_config() -> Optional[Path]:
    """Load the save directory from environment or config file."""
    # 1. Check environment variable (highest priority)
    env_path_str = os.getenv(SAVE_DIR_ENV_VAR)
    if env_path_str:
        try:
            expanded_path = os.path.expandvars(env_path_str)
            path = sanitize_path(expanded_path)
            path.mkdir(parents=True, exist_ok=True)
            return path
        except (OSError, PermissionError) as exc:
            q.print(f"âš ï¸  Could not use env var {SAVE_DIR_ENV_VAR}='{env_path_str}': {exc}", style="bold yellow")
    
    # 2. If no env var, check config file
    if CONFIG_FILE.is_file():
        try:
            with CONFIG_FILE.open("r") as f:
                data = json.load(f)
                path_str = data.get("save_dir")
                if path_str:
                    path = sanitize_path(path_str)
                    path.mkdir(parents=True, exist_ok=True)
                    return path
        except (json.JSONDecodeError, OSError, PermissionError) as exc:
             q.print(f"âš ï¸  Could not load config file at '{CONFIG_FILE}': {exc}", style="bold yellow")
    return None

def _save_config(save_dir: Optional[Path]) -> None:
    """Save the current save directory to the config file."""
    try:
        with CONFIG_FILE.open("w") as f:
            json.dump({"save_dir": str(save_dir) if save_dir else None}, f, indent=2)
    except OSError as exc:
        q.print(f"âš ï¸  Could not save to config file '{CONFIG_FILE}': {exc}", style="bold yellow")


# --- Public Interface (called by cli.py) ---
def run_guide(default_root: Path, default_depth: int, default_format: str, default_output: Optional[Path]) -> None:
    try:
        path_str = _abort_if_none(q.path("ğŸ“ 1. Directory to scan:", default=str(default_root)).ask())
        root_path = sanitize_path(path_str)
        params = _ask_tree_params(root_path, {"depth": default_depth, "fmt": default_format})
        output_str = _abort_if_none(q.text("ğŸ’¾ 2. Save to file? (leave blank for console)", default=str(default_output or "")).ask())
        output_path = sanitize_path(output_str) if output_str.strip() else None
        q.print("\nâ³ Generating your tree...", style="bold")
        generate_output(root=root_path, output_path=output_path, **params)
        if not output_path:
            q.print("\nâœ¨ Done!", style="bold green")
        q.print(SEPARATOR[0], style=SEPARATOR[1])
    except (QuestionaryError, KeyboardInterrupt):
        q.print("\nOperation cancelled.", style="bold red")
        sys.exit(0)
    except Exception as e:
        q.print(f"\nAn unexpected error occurred: {e}", style="bold red")
        sys.exit(1)

def run_menu(*args, **kwargs) -> None:
    save_dir = _load_config()
    try:
        q.print("Welcome to One-Click Context Menu Mode!", style="bold italic")
        if save_dir:
            q.print(f"Loaded save directory: {save_dir}", style="fg:#888888")

        while True:
            action = _abort_if_none(q.select(
                "ğŸ“‚ Main Menu:",
                choices=[
                    q.Choice("ğŸŒ³ Generate New Tree", value="generate"),
                    q.Choice(f"ğŸ’¾ Set/Change Save Directory (persists)", value="config"),
                    q.Separator(),
                    q.Choice("Exit", value="exit")
                ], use_indicator=True).ask())

            if action == "exit": break

            elif action == "config":
                path_str = _abort_if_none(q.path("Enter directory to save files in (leave blank to clear):", default=str(save_dir or "")).ask())
                new_save_dir = None
                if path_str.strip():
                    try:
                        new_save_dir = sanitize_path(path_str)
                        new_save_dir.mkdir(parents=True, exist_ok=True)
                        q.print(f"âœ… Save directory set to: {new_save_dir}", style="bold green")
                    except (OSError, PermissionError) as exc:
                        new_save_dir = None
                        q.print(f"âŒ Cannot use that directory: {exc}", style="bold red")
                else:
                    q.print("âœ… Save directory cleared.", style="bold green")

                save_dir = new_save_dir
                _save_config(save_dir)

            elif action == "generate":
                path_str = _abort_if_none(q.path("ğŸ“ Directory to scan:", default=".").ask())
                root_path = sanitize_path(path_str)
                params = _ask_tree_params(root_path, {})
                
                output_path = None
                if save_dir:
                    ts = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]
                    ext = "txt" if params["fmt"] == "text" else params["fmt"]
                    output_path = save_dir / f"tree_{ts}.{ext}"
                
                q.print("\nâ³ Generating your tree...", style="bold")
                generate_output(root=root_path, output_path=output_path, **params)
                
                if not output_path:
                    q.print("\nâœ¨ Done!", style="bold green")
                q.print(SEPARATOR[0], style=SEPARATOR[1])
    
    except (QuestionaryError, KeyboardInterrupt):
        q.print("\n\nGoodbye!", style="bold")
        sys.exit(0)
    except Exception as e:
        q.print(f"\nAn unexpected error occurred: {e}", style="bold red")
        sys.exit(1)

```

### ğŸ“„ src\oneclick_context\utils.py

```
ï»¿from pathlib import Path
from typing import Optional
import inspect, click, typer

COMMON_LIBS = ["node_modules", "dist", ".venv", ".git", "__pycache__"]

def _abort_if_none(val):
    """Exit CLI (code 0) when Questionary returns None (Esc / Ctrl-C)."""
    if val is None:
        raise typer.Exit()
    return val

def sanitize_path(raw: Optional[str]) -> Path:
    """
    Return absolute Path from user input.
    If *raw* is None/blank â†’ current working directory.
    """
    if raw is None or not str(raw).strip():
        return Path.cwd()
    return (
        Path(str(raw).strip().lstrip("./").strip('"'))
        .expanduser()
        .resolve()
    )

def discover_extensions(root: Path, suppress: list[str]) -> list[str]:
    """
    Return a sorted list of unique file suffixes ('.py', '.ts', â€¦)
    under *root*, skipping suppressed directories.
    """
    suppress_lc = {s.lower() for s in suppress}
    exts: set[str] = set()
    for p in root.rglob("*"):
        if not p.is_file() or not p.suffix:
            continue
        if any(part.lower() in suppress_lc for part in p.parts):
            continue
        exts.add(p.suffix)
    return sorted(exts, key=str.lower)


SUPPORTS_HYPERLINK = "hyperlink" in inspect.signature(click.style).parameters

```

### ğŸ“„ tests\__init__.py

```

```

### ğŸ“„ tests\test_cli.py

```
ï»¿from pathlib import Path
from typer.testing import CliRunner

from oneclick_context.cli import app

runner = CliRunner()

def test_json_output(tmp_path: Path):
    (tmp_path / "sub").mkdir()
    (tmp_path / "sub" / "a.txt").write_text("x")
    
    # The test now correctly calls the named --path option.
    result = runner.invoke(
        app, ["--path", str(tmp_path), "--fmt", "json"]
    )
    
    assert result.exit_code == 0, f"CLI exited with an error:\n{result.stdout}\n{result.stderr}"
    assert result.exception is None
    assert '"a.txt"' in result.stdout

def test_language_filter(tmp_path: Path):
    """Verify that the --lang flag correctly filters files by extension."""
    # Create a test structure with different file types
    (tmp_path / "a.py").write_text("python")
    (tmp_path / "b.js").write_text("javascript")
    (tmp_path / "c.toml").write_text("toml")

    # Run the command with filters for .py and .toml
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--lang", ".py",
        "--lang", ".toml"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains the desired files
    assert "a.py" in result.stdout
    assert "c.toml" in result.stdout

    # Assert that the filtered-out file is NOT in the output
    assert "b.js" not in result.stdout

def test_markdown_output(tmp_path: Path):
    """Verify that the --format md flag produces a collapsible Markdown block."""
    # Create a dummy file in the temp directory
    (tmp_path / "file.txt").write_text("content")

    # Run the command to generate Markdown output
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--format", "md"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains the key elements of our Markdown format
    assert "<details><summary>" in result.stdout
    assert "```text" in result.stdout
    assert "file.txt" in result.stdout
    assert "```" in result.stdout
    assert "</details>" in result.stdout

def test_html_output(tmp_path: Path):
    """Verify that the --format html flag produces a collapsible HTML list."""
    # Create a dummy file in the temp directory
    (tmp_path / "file.txt").write_text("content")

    # Run the command to generate HTML output
    result = runner.invoke(app, [
        "--path", str(tmp_path),
        "--format", "html"
    ])

    # Assert the command ran successfully
    assert result.exit_code == 0
    assert result.exception is None

    # Assert that the output contains key HTML tags for a nested list
    assert "<ul>" in result.stdout
    assert "<li>" in result.stdout
    assert "<details><summary>" in result.stdout
    assert "file.txt" in result.stdout
    assert "</details>" in result.stdout
    assert "</ul>" in result.stdout

```

### ğŸ“„ tests\test_prompts.py

```
ï»¿# tests/test_prompts.py
import sys
from pathlib import Path
from unittest.mock import MagicMock

import pytest
import questionary as q

# Correctly import the specific exception class for modern versions,
# with a fallback for older ones.
try:
    from questionary import QuestionaryError
except ImportError:
    class QuestionaryError(Exception):
        pass

from oneclick_context.prompts import run_guide

# â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Stub:
    """Minimal object mimicking a Questionary prompt: .ask() -> value."""
    def __init__(self, value):
        self._value = value

    def ask(self):
        if self._value is None:
            raise QuestionaryError("User cancelled.")
        return self._value

def make_stub_sequence(answers):
    """Return a function that pops answers in FIFO order each call."""
    queue = list(answers)
    def _factory(*_args, **_kwargs):
        if not queue:
            raise AssertionError("Test stub queue exhausted. More prompts were called than answers provided.")
        return Stub(queue.pop(0))
    return _factory

# â”€â”€ tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def test_run_guide_happy_path(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """End-to-end test of the interactive guide using Questionary stubs."""
    answers = [
        str(tmp_path), "2", True, [".py", ".md"], "md", str(tmp_path / "output.md"),
    ]

    stub_factory = make_stub_sequence(answers)
    monkeypatch.setattr("questionary.path", stub_factory)
    monkeypatch.setattr("questionary.text", stub_factory)
    monkeypatch.setattr("questionary.confirm", stub_factory)
    monkeypatch.setattr("questionary.checkbox", stub_factory)
    monkeypatch.setattr("questionary.select", stub_factory)

    # Mock the print function to prevent console errors during test runs
    monkeypatch.setattr("questionary.print", MagicMock())
    
    monkeypatch.setattr("oneclick_context.prompts.discover_extensions", lambda *args, **kwargs: [".py", ".md", ".js"])

    mock_generate = MagicMock()
    monkeypatch.setattr("oneclick_context.prompts.generate_output", mock_generate)

    run_guide(default_root=tmp_path, default_depth=3, default_format="text", default_output=None)

    mock_generate.assert_called_once()
    kwargs = mock_generate.call_args.kwargs
    assert kwargs["root"] == tmp_path
    assert kwargs["depth"] == 2
    assert kwargs["fmt"] == "md"
    assert kwargs["output_path"] == tmp_path / "output.md"
    assert kwargs["languages"] == (".py", ".md")

```

### ğŸ“„ tests\test_smoke.py

```
ï»¿def test_smoke():
    assert True

```